# yt-dlp-gui 项目 Wrappers 模块详细分析报告

## 一、DLP.cs 文件详细分析

### 1.1 文件概述
DLP.cs 文件是 yt-dlp-gui 项目中最重要的核心组件之一，它是一个对 yt-dlp 命令行工具的 C# 封装类。该文件实现了对视频下载、信息获取、格式选择等核心功能的封装，使得 WPF 应用程序能够方便地调用 yt-dlp 工具。

### 1.2 命名空间和引用
```csharp
using Libs;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using yt_dlp_gui.Models;
```
- `Libs`: 引用项目内部的工具库
- `System.*`: 标准 .NET 库，用于进程管理、文件操作、正则表达式等
- `yt_dlp_gui.Models`: 引用项目的数据模型

### 1.3 类定义和枚举
```csharp
namespace yt_dlp_gui.Wrappers {
    public class DLP {
        public enum DLPType {
            yd_dlp, youtube_dl
        }
```
- 定义了 `DLPType` 枚举，区分 yt-dlp 和 youtube-dl 两种不同的工具类型
- `yd_dlp`: 表示使用 yt-dlp 工具
- `youtube_dl`: 表示使用 youtube-dl 工具

### 1.4 静态属性
```csharp
static public DLPType Type { get; set; } = DLPType.yd_dlp;
static public string Path_DLP { get; set; } = string.Empty;
static public string Path_Aria2 { get; set; } = string.Empty;
static public string Path_FFMPEG { get; set; } = string.Empty;
```
- `Type`: 当前使用的工具类型，默认为 yt-dlp
- `Path_DLP`: yt-dlp 可执行文件的路径
- `Path_Aria2`: Aria2 下载器的路径
- `Path_FFMPEG`: FFmpeg 工具的路径

这些静态属性在整个应用程序中共享，确保所有 DLP 实例使用相同的工具路径。

### 1.5 实例属性
```csharp
public List<string> Files { get; set; } = new List<string>();
public Dictionary<string, string> Options { get; set; } = new Dictionary<string, string>();
public string Url { get; set; } = string.Empty;
public bool IsLive { get; set; } = false;
public HashSet<DLPError> StdErr { get; set; } = new();
Process process = new();
public enum DLPError { Sign, Unsupported }
```
- `Files`: 存储下载过程中生成的文件列表
- `Options`: 存储传递给 yt-dlp 的命令行参数
- `Url`: 要处理的视频 URL
- `IsLive`: 标识是否为直播流
- `StdErr`: 存储错误类型集合
- `process`: 用于执行外部进程的 Process 对象
- `DLPError`: 定义可能的错误类型（签名错误、不支持错误）

### 1.6 构造函数分析
```csharp
public DLP(string url = "") {
    Url = url;
    Options["--no-playlist"] = "";
    //Options["--no-part"] = "";
    Options["--force-overwrites"] = "";
    Options["--ignore-config"] = "";
    Options["--ffmpeg-location"] = Path_FFMPEG.QP();
    if (Type == DLPType.yd_dlp) {
        Options["--progress-template"] = "\""
            + "[yt-dlp]," //0
            + "%(progress._percent_str)s," //1
            + "%(progress._eta_str)s," //2
            + "%(progress.downloaded_bytes)s," //3
            + "%(progress.total_bytes)s," //4
            + "%(progress.speed)s," //5
            + "%(progress.eta)s" //6
            + "\"";
        Options["--windows-filenames"] = "";
    }
}
```
构造函数初始化一个新的 DLP 实例：
- 设置基本选项：禁用播放列表、强制覆盖、忽略配置文件
- 设置 FFmpeg 位置
- 如果使用 yt-dlp，设置进度模板和 Windows 文件名格式

### 1.7 配置加载方法
```csharp
public DLP LoadConfig(string path) {
    if (!string.IsNullOrWhiteSpace(path) && File.Exists(path)) {
        Options.Remove("--ignore-config");
        Options["--config-location"] = path.QP();
    }
    return this;
}
```
- 检查配置文件是否存在
- 移除忽略配置的选项
- 设置配置文件位置
- 返回当前实例以支持链式调用

### 1.8 输出路径设置方法
```csharp
public DLP Output(string targetpath) {
    Options["--output"] = targetpath.QP();
    return this;
}
```
- 设置输出路径，使用 QP 扩展方法进行路径处理
- 支持链式调用

### 1.9 修改时间处理方法
```csharp
public DLP MTime(ModifiedType type = ModifiedType.Modified) {
    if (type == ModifiedType.Created) {
        Options["--no-mtime"] = "";
    }
    return this;
}
```
- 根据修改时间类型设置相应选项
- 如果是创建日期类型，则禁用修改时间设置

### 1.10 临时目录设置方法
```csharp
public DLP Temp(string path) {
    Options["--cache-dir"] = path.QP();
    Options["[temp]"] = path.QP("temp");
    return this;
}
```
- 设置缓存目录
- 添加临时路径标记用于后续处理

### 1.11 代理设置方法
```csharp
public DLP Proxy(string proxy_url, bool enable = true) {
    if (enable) {
        Options["--proxy"] = proxy_url.QS();
    }
    return this;
}
```
- 如果启用代理，则设置代理 URL
- 使用 QS 方法添加引号包围

### 1.12 下载片段设置方法
```csharp
public DLP DownloadSections(string regex) {
    if (!string.IsNullOrWhiteSpace(regex)) {
        Options["--download-sections"] = regex.QS();
    }
    return this;
}
```
- 设置下载特定时间段的选项
- 用于下载视频的特定部分

### 1.13 章节分割方法
```csharp
public DLP SplitChapters(Chapters chapters, string path = "") {
    switch (chapters.type) {
        case ChaptersType.Split:
            Options["--split-chapters"] = "";
            Options["[chapter]"] = path.suffix(" - %(section_number)03d. %(section_title)s").QP("chapter");
            break;
        case ChaptersType.Segment:
            if (!string.IsNullOrWhiteSpace(chapters.title)) {
                Options["--download-sections"] = chapters.title.QS();
            }
            break;
    }
    return this;
}
```
- 根据章节类型设置不同的处理方式
- Split 类型：分割章节为独立文件
- Segment 类型：下载特定时间段

### 1.14 嵌入章节方法
```csharp
public DLP EmbedChapters(bool enable) {
    if (enable) {
        Options["--embed-chapters"] = "";
    }
    return this;
}
```
- 如果启用，则设置嵌入章节选项

### 1.15 缩略图处理方法
```csharp
public DLP Thumbnail(bool enable, string path, bool embed) {
    if (enable) {
        if (embed) {
            Options["--embed-thumbnail"] = "";
        } else {
            Options["--write-thumbnail"] = "";
            Options["--convert-thumbnails"] = "jpg";
        }
        var target = Path.ChangeExtension(path, ".%(ext)s").QP("thumbnail");
        Options["[thumbnail]"] = target;
        Files.Add(Path.ChangeExtension(path, ".jpg")); //predict
    }
    return this;
}
```
- 根据 embed 参数决定是嵌入还是单独保存缩略图
- 设置缩略图转换格式为 JPG
- 预测并添加缩略图文件到文件列表

### 1.16 字幕处理方法
```csharp
public DLP Subtitle(string lang, string targetpath, bool embed) {
    if (string.IsNullOrWhiteSpace(lang)) return this;
    Options["--sub-langs"] = lang;
    if (embed) {
        Options["--embed-subs"] = "";
    } else {
        Options["--write-subs"] = "";
        Options["--convert-subs"] = "srt";
        var target = Path.ChangeExtension(targetpath, ".%(ext)s").QP("subtitle");
        Options["[subtitle]"] = target;
        Files.Add(Path.ChangeExtension(targetpath, $".{lang}.srt"));
    }
    return this;
}
```
- 设置字幕语言
- 根据 embed 参数决定嵌入或单独保存
- 添加字幕文件到预测列表

### 1.17 获取信息方法
```csharp
public DLP GetInfo() {
    Options["--dump-json"] = "";
    return this;
}
```
- 设置 JSON 输出选项，用于获取视频信息

### 1.18 Aria2 下载器方法
```csharp
public DLP UseAria2(bool enable = true) {
    if (enable) {
        if (File.Exists(Path_Aria2)) {
            Options["--external-downloader"] = Path_Aria2.QP();
            //Options["--external-downloader"] = "aria2c";
            //Options["--downloader-args"] = "aria2c:\"-x 16 -k 10M --user-agent=''\"";
            if (Options.ContainsKey("--proxy")) {
                Options["--external-downloader-args"] = "'--all-proxy=" + Options["--proxy"] + "'";
            }
        }
    }
    return this;
}
```
- 检查 Aria2 是否存在
- 设置外部下载器为 Aria2
- 如果设置了代理，则传递代理参数给 Aria2

### 1.19 限速方法
```csharp
public DLP LimitRate(string value) {
    if (!string.IsNullOrWhiteSpace(value)) {
        Options["--limit-rate"] = value;
    }
    return this;
}
```
- 设置下载速度限制

### 1.20 Cookie 处理方法
```csharp
public DLP Cookie(CookieType type, bool enable = true) {
    if (enable) {
        switch (type) {
            case CookieType.Chrome:
                Options["--cookies-from-browser"] = $"chrome";
                break;
            case CookieType.Edge:
                Options["--cookies-from-browser"] = $"edge";
                break;
            case CookieType.Firefox:
                Options["--cookies-from-browser"] = $"firefox";
                break;
            case CookieType.Opera:
                Options["--cookies-from-browser"] = $"opera";
                break;
            case CookieType.Chromium:
                Options["--cookies-from-browser"] = $"chromium";
                break;
            case CookieType.Chrome_Beta:
                var AppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
                var CookiePath = Path.Combine(AppData, "Google", "Chrome Beta");
                Options["--cookies-from-browser"] = $"chrome:{CookiePath}";
                break;
        }
    }
    return this;
}
```
- 根据浏览器类型设置 Cookie 获取选项
- 特殊处理 Chrome Beta 版本的路径

### 1.21 参数构建属性
```csharp
private string Args {
    get {
        var args = Options.Select(x => {
            var key = x.Key;
            switch (key) {
                case "[temp]":
                    //key = "--paths";
                    key = "--output";
                    break;
                case "[chapter]":
                case "[thumbnail]":
                case "[subtitle]":
                    key = "--output";
                    break;
            }
            if (string.IsNullOrWhiteSpace(x.Value)) {
                return key;
            } else {
                return $"{key} {x.Value}";
            }
        }).ToList();
        args.Add(Url.QS());
        return string.Join(" ", args);
    }
}
```
- 将选项字典转换为命令行参数字符串
- 处理特殊键的映射
- 添加 URL 参数

### 1.22 下载格式方法
```csharp
public DLP DownloadFormat(string format_id, string targetpath, string originext) {
    Debug.WriteLine($"id:{format_id} path:{targetpath}", "DownloadFormat");
    Options["--format"] = format_id;
    if (targetpath.getExt() != originext) {
        Options["--remux-video"] = targetpath.getExt();
    }
    Options["--output"] = Path.ChangeExtension(targetpath, ".%(ext)s").QP();
    Files.Add(targetpath);
    return this;
}
```
- 设置下载格式 ID
- 如果目标扩展名与原始扩展名不同，则设置重新封装选项
- 添加目标文件到文件列表

### 1.23 下载视频方法
```csharp
public DLP DownloadVideo(string format_id, string source_ext, string targetpath) {
    Debug.WriteLine($"id:{format_id} source:{source_ext} path:{targetpath}", "DownloadVideo");
    Options["--format"] = format_id;
    if (source_ext == targetpath.getExt()) {
        Options["--output"] = targetpath.QP();
    } else {
        Options["--remux-video"] = targetpath.getExt();
        Options["--output"] = targetpath.QP();
    }
    return this;
}
```
- 设置视频格式和输出路径
- 根据扩展名决定是否需要重新封装

### 1.24 下载音频方法
```csharp
public DLP DownloadAudio(string audio_id, string target) {
    Options["--extract-audio"] = "";
    if (target.isAudio()) {
        Options["--audio-format"] = target.getExt().QS();
    }
    Options["--format"] = audio_id;
    Options["--output"] = target.RemoveExt().QP();
    return this;
}
```
- 设置提取音频选项
- 根据目标文件类型设置音频格式
- 移除扩展名后设置输出路径

### 1.25 下载字幕方法
```csharp
public DLP DownloadSubtitle(string lang, string targetpath) {
    //Default
    if (!Path.HasExtension(targetpath)) Path.ChangeExtension(targetpath, ".srt");
    var exts = Path.GetExtension(targetpath).Trim('.').ToLower();
    Options["--write-subs"] = "";
    Options["--sub-langs"] = lang;
    if (new[] { "vtt", "ttml", "srv3", "srv2", "srv1", "json3" }.Contains(exts)) {
        Options["--sub-format"] = exts;
    } else if (new[] { "ass", "lrc", "srt" }.Contains(exts)) {
        Options["--convert-subs"] = exts;
    }
    var subpath = Path.ChangeExtension(targetpath, null);
    Options["--skip-download"] = "";
    Options["[subtitle]"] = subpath.QP("subtitle");
    return this;
}
```
- 设置字幕下载选项
- 根据目标扩展名决定使用原生格式还是转换格式
- 设置跳过下载选项（因为只下载字幕）

### 1.26 错误检测正则表达式
```csharp
private static Regex ErrSign = new Regex(@"^(?=.*?ERROR)(?=.*?sign)(?=.*?confirm)", RegexOptions.IgnoreCase);
private static Regex ErrUnsupported = new Regex(@"^(?=.*?ERROR)(?=.*?Unsupported)", RegexOptions.IgnoreCase);
```
- 定义两个正则表达式用于检测特定错误类型
- `ErrSign`: 检测需要确认签名的错误
- `ErrUnsupported`: 检测不支持的错误

### 1.27 执行方法
```csharp
public Process Exec(Action<string> stdall = null, Action<string> stdout = null, Action<string> stderr = null) {
    var fn = Path_DLP;
    if (!File.Exists(fn)) {
        return null;
    }
    var info = new ProcessStartInfo() {
        FileName = fn,
        Arguments = Args,
        UseShellExecute = false,
        CreateNoWindow = true,
        RedirectStandardInput = true,
        RedirectStandardOutput = true,
        RedirectStandardError = true,
    };
    //Debug.WriteLine(Args);
    Debug.WriteLine($"{info.FileName} {info.Arguments}");
    process.StartInfo = info;
    process.EnableRaisingEvents = true;
    process.OutputDataReceived += (s, e) => {
        Debug.WriteLine(e.Data, "STD");
        if (!string.IsNullOrWhiteSpace(e.Data)) {
            stdall?.Invoke(e.Data);
            stdout?.Invoke(e.Data);
        }
    };
    process.ErrorDataReceived += (s, e) => {
        Debug.WriteLine(e.Data, "ERR");
        if (!string.IsNullOrWhiteSpace(e.Data)) {
            stdall?.Invoke(e.Data);
            stderr?.Invoke(e.Data);
            if (ErrSign.IsMatch(e.Data)) {
                StdErr.Add(DLPError.Sign);
            }
            if (ErrUnsupported.IsMatch(e.Data)) StdErr.Add(DLPError.Unsupported);
        }
    };

    process.Start();
    process.BeginErrorReadLine();
    process.BeginOutputReadLine();
    process.WaitForExit();
    return process;
}
```
- 创建并启动外部进程
- 重定向标准输入、输出和错误流
- 实时处理输出数据并检测错误
- 支持回调函数处理输出数据

### 1.28 关闭方法
```csharp
public DLP Close() {
    Debug.WriteLine("CLOSE");
    Util.SendCtrlC(process);
    if (Options.ContainsKey("--output")) {
        var tempfile = Options["--output"];
        if (!IsLive) {
            if (File.Exists(tempfile)) File.Delete(tempfile);
        }
    }
    return this;
}
```
- 发送 Ctrl+C 信号终止进程
- 删除临时文件（如果不是直播）

### 1.29 错误处理方法
```csharp
public DLP Err(DLPError err, Action callback) {
    if (StdErr.Contains(err)) callback.Invoke();

    return this;
}
```
- 检查是否发生了指定类型的错误
- 如果发生错误则执行回调函数

### 1.30 扩展方法类
```csharp
public static class DLPExtend {
    public static string QS(this string str) {
        return $"\"{str}\"";
    }
    public static string QP(this string path, string prefix = "") {
        var p = path.Replace(Path.DirectorySeparatorChar, '/');
        if (string.IsNullOrWhiteSpace(prefix)) {
            return p.QS();
        } else {
            return $"{prefix}:{p}".QS();
        }
    }
```
- `QS`: 为字符串添加双引号包围
- `QP`: 处理路径，替换分隔符并可选添加前缀

### 1.31 文件类型检测扩展方法
```csharp
public static bool isVideo(this string path) {
    if (!Path.HasExtension(path)) return false;
    var exts = new[] { "avi", "flv", "mkv", "mov", "mp4", "webm" };
    return exts.Contains(Path.GetExtension(path).ToLower().Trim('.'));
}

public static bool isAudio(this string path) {
    if (!Path.HasExtension(path)) return false;
    var exts = new[] { "aac", "aiff", "alac", "flac", "m4a", "mka", "mp3", "ogg", "opus", "vorbis", "wav" };
    return exts.Contains(Path.GetExtension(path).ToLower().Trim('.'));
}

public static bool isImage(this string path) {
    if (!Path.HasExtension(path)) return false;
    var exts = new[] { "gif", "jpg", "png", "webp" };
    return exts.Contains(Path.GetExtension(path).ToLower().Trim('.'));
}

public static bool isSubtitle(this string path) {
    if (!Path.HasExtension(path)) return false;
    var exts = new[] { "vtt", "ttml", "srv3", "srv2", "srv1", "json3" };
    return exts.Contains(Path.GetExtension(path).ToLower().Trim('.'));
}
```
- 提供各种媒体文件类型的检测方法
- 通过文件扩展名判断文件类型

### 1.32 路径处理扩展方法
```csharp
public static string getExt(this string path) {
    return Path.GetExtension(path).Trim('.').ToLower();
}

public static string suffix(this string path, string suffix) {
    var oriExt = Path.GetExtension(path);
    return Path.ChangeExtension(Path.ChangeExtension(path, null) + suffix, oriExt);
}
```
- `getExt`: 获取文件扩展名（去除点号并转小写）
- `suffix`: 为文件名添加后缀但保持原有扩展名

## 二、FFMPEG.cs 文件详细分析

### 2.1 文件概述
FFMPEG.cs 文件是对 FFmpeg 命令行工具的 C# 封装类，主要用于视频处理操作，如合并音视频、分割章节、从 URL 下载等。

### 2.2 命名空间和引用
```csharp
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using yt_dlp_gui.Models;
```
- 引用标准 .NET 库和项目模型

### 2.3 类定义
```csharp
public class FFMPEG {
    public static string Path_FFMPEG { get; set; } = string.Empty;
```
- 定义 FFmpeg 可执行文件路径的静态属性

### 2.4 合并方法
```csharp
public static void Merger(bool overwrite, string target, params string[] sources) {
    var options = new List<string>();
    foreach (var source in sources) {
        options.Add($"-i \"{source}\"");
    }
    options.Add("-vcodec copy");
    options.Add("-acodec copy");
    if (Path.GetExtension(target).ToLower() == ".mp4") options.Add("-c:s mov_text");
    if (overwrite) {
        options.Add("-y");
    } else {
        options.Add("-n");
    }
    options.Add($"\"{target}\"");
    var args = string.Join(" ", options);
    Debug.WriteLine(args);
    Exec(args);
}
```
- 合并多个媒体文件
- 使用 copy 编解码器避免重新编码
- 针对 MP4 格式特殊处理字幕编解码器
- 支持覆盖或不覆盖现有文件

### 2.5 分割方法
```csharp
public static void Split(string target, string source, Chapters chapter) {
    var options = new List<string>();
    options.Add($"-accurate_seek -i \"{source}\"");
    options.Add("-vcodec copy");
    options.Add("-acodec copy");
    options.Add("-avoid_negative_ts make_zero");
    options.Add("-y");
    options.Add($"-ss \"{chapter.start_time}\"");
    options.Add($"-to \"{chapter.end_time}\"");
    options.Add($"\"{target}\"");
    var args = string.Join(" ", options);
    Debug.WriteLine(args);
    Exec(args);
}
```
- 根据章节信息分割视频
- 使用精确寻址确保准确切割
- 设置开始和结束时间
- 避免负时间戳问题

### 2.6 URL 下载方法
```csharp
public static void DownloadUrl(string url, string target) {
    var options = new List<string>();
    options.Add($"-i \"{url}\"");
    options.Add("-y");
    options.Add($"\"{target}\"");
    var args = string.Join(" ", options);
    Exec(args);
}
```
- 从 URL 直接下载媒体内容
- 强制覆盖目标文件

### 2.7 内部执行方法
```csharp
private static void Exec(string args = "") {
    //var fn = App.Path(App.Folders.bin, "ffmpeg.exe");
    var fn = Path_FFMPEG;
    Process p = new Process();
    p.StartInfo.FileName = fn;
    p.StartInfo.Arguments = args;
    p.StartInfo.UseShellExecute = false;
    p.StartInfo.CreateNoWindow = true;
    p.StartInfo.RedirectStandardOutput = true;
    p.StartInfo.RedirectStandardError = true;
    p.EnableRaisingEvents = true;
    p.OutputDataReceived += (s, e) => {
        //Debug.WriteLine(e.Data, "STD");
    };
    p.ErrorDataReceived += (s, e) => {
        //Debug.WriteLine(e.Data, "ERR");
    };
    p.Start();
    p.BeginErrorReadLine();
    p.BeginOutputReadLine();
    p.WaitForExit();
}
```
- 创建并执行 FFmpeg 进程
- 重定向输入输出流
- 等待进程完成

## 三、两个文件的关系和作用

### 3.1 功能关系
- DLP.cs 是主要的视频下载和信息获取工具，负责调用 yt-dlp
- FFMPEG.cs 是辅助的媒体处理工具，负责音视频合并、分割等操作
- 两者都通过进程调用外部命令行工具

### 3.2 在项目中的作用
- DLP.cs: 核心下载引擎，处理所有与视频下载相关的操作
- FFMPEG.cs: 媒体处理助手，处理下载后的媒体文件

### 3.3 设计模式
- 两者都采用了封装外部工具的设计模式
- 使用链式调用提高代码可读性
- 提供丰富的配置选项满足不同需求

## 四、总结

这两个文件是 yt-dlp-gui 项目的核心组件，通过封装外部命令行工具实现了完整的视频下载和处理功能。DLP.cs 负责主要的下载逻辑，而 FFMPEG.cs 提供辅助的媒体处理功能。它们的设计体现了良好的封装性和易用性，为上层应用程序提供了简洁的 API 接口。